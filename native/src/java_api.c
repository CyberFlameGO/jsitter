/* DO NOT EDIT THIS FILE - it is machine generated */
#include <jni.h>
#include <tree_sitter/api.h>
#include <string.h>
#include "subtree.h"

/* Header for class jsitter_interop_JSitter */
    TSLanguage *tree_sitter_go();
    
    TSLanguage *tree_sitter_json();
    
    /*
     * Class:     jsitter_interop_JSitter
     * Method:    getSymbolName
     * Signature: (JS)Ljava/lang/String;
     */
    JNIEXPORT jstring JNICALL Java_jsitter_interop_JSitter_getSymbolName
    (JNIEnv *env, jclass cl, jlong language_ptr, jint ts_symbol) {
        const char *name = ts_language_symbol_name((TSLanguage *)language_ptr, (TSSymbol)ts_symbol);
        return (*env)->NewStringUTF(env, name);
    }
    
    /*
     * Class:     jsitter_interop_JSitter
     * Method:    isTerminal
     * Signature: (JS)Z
     */
    JNIEXPORT jboolean JNICALL Java_jsitter_interop_JSitter_isTerminal
    (JNIEnv *env, jclass class, jlong language_ptr, jint ts_symbol) {
        return ts_language_symbol_type((TSLanguage*)language_ptr, (TSSymbol)ts_symbol) == TSSymbolTypeAnonymous;
    }
    
    JNIEXPORT jboolean JNICALL JavaCritical_jsitter_interop_JSitter_isTerminal
    (jlong language_ptr, jint ts_symbol) {
        return ts_language_symbol_type((TSLanguage*)language_ptr, (TSSymbol)ts_symbol) == TSSymbolTypeAnonymous;
    }
    
    /*
     * Class:     jsitter_interop_JSitter
     * Method:    getSymbolByName
     * Signature: (JLjava/lang/String;)S
     */
    JNIEXPORT jint JNICALL Java_jsitter_interop_JSitter_getSymbolByName
    (JNIEnv *env, jclass class, jlong language_ptr, jstring name) {
        jboolean copy;
        const char *chars = (*env)->GetStringUTFChars(env, name, &copy);
        TSSymbol symbol = ts_language_symbol_for_name((TSLanguage *)language_ptr, chars);
        if (copy) {
            (*env)->ReleaseStringUTFChars(env, name, chars);
        }
        return symbol;
    }
    
    JNIEXPORT void JNICALL Java_jsitter_interop_JSitter_releaseSubtree
    (JNIEnv *env , jclass class, jlong subtree_ptr) {
        SubtreePool pool = ts_subtree_pool_new(0);
        ts_subtree_release(&pool, *(Subtree *)(&subtree_ptr));
        ts_subtree_pool_delete(&pool);
    }
    
    JNIEXPORT void JNICALL Java_jsitter_interop_JSitter_retainSubtree
    (JNIEnv *env , jclass class, jlong subtree_ptr) {
        ts_subtree_retain(*(Subtree *)(&subtree_ptr));
    }
    
    /*
     * Class:     jsitter_interop_JSitter
     * Method:    releaseTree
     * Signature: (J)V
     */
    JNIEXPORT void JNICALL Java_jsitter_interop_JSitter_releaseTree
    (JNIEnv *env , jclass class, jlong tree_ptr) {
        ts_tree_delete((TSTree *)tree_ptr);
    }
    
    /*
     * Class:     jsitter_interop_JSitter
     * Method:    releaseParser
     * Signature: (J)V
     */
    JNIEXPORT void JNICALL Java_jsitter_interop_JSitter_releaseParser
    (JNIEnv *env , jclass class, jlong parser_ptr) {
        ts_parser_delete((TSParser *)parser_ptr);
    }
    
    struct Input {
        JNIEnv *env;
        jobject input;
        jmethodID read_mtd;
        const char *reading_addr;
    };
    
    const char *input_jni_read(void *payload, uint32_t byte_index, TSPoint position, uint32_t *bytes_read) {
        struct Input *input = (struct Input *)payload;
        jint read = (*input->env)->CallIntMethod(input->env, input->input, input->read_mtd, byte_index);
        *bytes_read = read;
        return input->reading_addr;
    }
    
    static jmethodID read_mtd = 0;
    
    /*
     * Class:     jsitter_interop_JSitter
     * Method:    parse
     * Signature: (JJLjsitter/interop/JSitter/Input;JIII)J
     */
    JNIEXPORT jlong JNICALL Java_jsitter_interop_JSitter_parse
    (JNIEnv *env, jclass class, jlong parser_ptr, jlong old_tree_ptr, jobject input, jint encoding, jobject reading_buffer, jint start_byte, jint old_end_byte, jint new_end_byte) {
        if (read_mtd == 0) {
            jclass input_class = (*env)->FindClass(env, "jsitter/interop/JSitter$Input");
            read_mtd = (*env)->GetMethodID(env, input_class, "read", "(I)I");
        }
        void *reading_addr = (*env)->GetDirectBufferAddress(env, reading_buffer);
        struct Input input_ctx;
        input_ctx.env = env;
        input_ctx.input = input;
        input_ctx.read_mtd = read_mtd;
        input_ctx.reading_addr = (const char *)reading_addr;
        
        TSInput ts_input;
        ts_input.encoding = (TSInputEncoding)encoding;
        ts_input.payload = &input_ctx;
        ts_input.read = &input_jni_read;
        
        TSParser *parser = (TSParser *)parser_ptr;
        if (old_tree_ptr) {
            TSTree *old_tree = (TSTree *)old_tree_ptr;
            TSTree *old_tree_copy = ts_tree_copy(old_tree);
            TSInputEdit edit;
            edit.start_byte = start_byte;
            edit.old_end_byte = old_end_byte;
            edit.new_end_byte = new_end_byte;
            ts_tree_edit(old_tree_copy, &edit);
            
            TSTree *new_tree = ts_parser_parse(parser, old_tree_copy, ts_input);
            ts_tree_delete(old_tree_copy);
            return (jlong)new_tree;
        } else {
            return (jlong) ts_parser_parse(parser, NULL, ts_input);
        }
    }
    
    /*
     * Class:     jsitter_interop_JSitter
     * Method:    newParser
     * Signature: (J)J
     */
    JNIEXPORT jlong JNICALL Java_jsitter_interop_JSitter_newParser
    (JNIEnv * env, jclass class, jlong language_ptr) {
        TSParser *parser = ts_parser_new();
        ts_parser_set_language(parser, (TSLanguage *)language_ptr);
        return (jlong) parser;
    }
    
    JNIEXPORT jlong JNICALL JavaCritical_jsitter_interop_JSitter_newParser
    (jlong language_ptr) {
        TSParser *parser = ts_parser_new();
        ts_parser_set_language(parser, (TSLanguage *)language_ptr);
        return (jlong) parser;
    }
    
    JNIEXPORT jlong JNICALL Java_jsitter_interop_JSitter_findLanguage
    (JNIEnv *env, jclass class, jstring name) {
        jboolean copy;
        const char *language_name = (*env)->GetStringUTFChars(env, name, &copy);
        TSLanguage *lang = NULL;
        if (!strcmp(language_name, "go")) {
            lang = tree_sitter_go();
        } else if (!strcmp(language_name, "json")) {
            lang = tree_sitter_json();
        }
        if (copy) {
            (*env)->ReleaseStringUTFChars(env, name, language_name);
        }
        return (jlong) lang;
    }

